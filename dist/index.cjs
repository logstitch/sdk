'use strict';var a=class o extends Error{status;code;requestId;constructor(e,t,r,n){super(e),this.name="LogStitchError",this.status=t,this.code=r,this.requestId=n;}static async fromResponse(e){let t="unknown_error",r=`HTTP ${e.status}`,n="";try{let s=await e.json();s.error&&(t=s.error.code??t,r=s.error.message??r),n=s.request_id??"";}catch{}return new o(r,e.status,t,n)}};async function c(o,e,t){let r=3,n=500,s=3e4,u;for(let i=0;i<r;i++){let h;try{h=await fetch(o,e);}catch(p){if(u=p instanceof Error?p:new Error(String(p)),i<r-1){await d(y(i,n,s));continue}throw u}if(h.ok||h.status>=400&&h.status<500)return h;u=new Error(`HTTP ${h.status}`),i<r-1&&await d(y(i,n,s));}throw u??new Error("fetchWithRetry: exhausted retries")}function y(o,e,t){let r=e*2**o,n=Math.min(r,t),s=n*Math.random();return n+s}function d(o){return new Promise(e=>setTimeout(e,o))}var l=class{queue=[];timer=null;batchSize;flushInterval;maxQueueSize;onFlush;flushing=false;constructor(e){this.batchSize=e.batchSize,this.flushInterval=e.flushInterval,this.maxQueueSize=e.maxQueueSize,this.onFlush=e.onFlush;}enqueue(e){this.queue.length>=this.maxQueueSize||(e.idempotency_key||(e={...e,idempotency_key:crypto.randomUUID()}),this.queue.push(e),this.startTimer(),this.queue.length>=this.batchSize&&this.flush());}async flush(){if(this.flushing||this.queue.length===0)return;this.flushing=true;let e=this.queue.splice(0);try{await this.onFlush(e);}finally{this.flushing=false;}}async close(){this.stopTimer(),await this.flush();}get size(){return this.queue.length}startTimer(){this.timer===null&&(this.timer=setInterval(()=>{this.flush();},this.flushInterval));}stopTimer(){this.timer!==null&&(clearInterval(this.timer),this.timer=null);}};var v="https://logstitch.io",E=10,f=5e3,w=1e3,m=class{baseUrl;projectKey;strict;onError;queue;events;viewerTokens;constructor(e){if(!e.projectKey)throw new Error("LogStitch: projectKey is required");this.projectKey=e.projectKey,this.baseUrl=(e.baseUrl??v).replace(/\/+$/,""),this.strict=e.strict??false,this.onError=e.onError,this.queue=new l({batchSize:e.batchSize??E,flushInterval:e.flushInterval??f,maxQueueSize:e.maxQueueSize??w,onFlush:t=>this._send(t)}),this.events={list:t=>this._listEvents(t)},this.viewerTokens={create:t=>this._createViewerToken(t)};}async log(e){try{this.queue.enqueue(e);}catch(t){this._handleError(t);}}async logBatch(e){let t=e.map(r=>r.idempotency_key?r:{...r,idempotency_key:crypto.randomUUID()});return this._sendAndReturn(t)}async flush(){await this.queue.flush();}async close(){await this.queue.close();}async _send(e){try{await this._sendAndReturn(e);}catch(t){this._handleError(t);}}async _sendAndReturn(e){let t=await c(`${this.baseUrl}/api/v1/events`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.projectKey}`},body:JSON.stringify(e.length===1?e[0]:e)});if(!t.ok)throw await a.fromResponse(t);return await t.json()}async _listEvents(e){let t=new URLSearchParams;if(e)for(let[u,i]of Object.entries(e))i!=null&&t.set(u,String(i));let r=t.toString(),n=`${this.baseUrl}/api/v1/events${r?`?${r}`:""}`,s=await c(n,{method:"GET",headers:{Authorization:`Bearer ${this.projectKey}`}});if(!s.ok)throw await a.fromResponse(s);return await s.json()}async _createViewerToken(e){let t=await c(`${this.baseUrl}/api/v1/viewer-tokens`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.projectKey}`},body:JSON.stringify(e)});if(!t.ok)throw await a.fromResponse(t);return await t.json()}_handleError(e){let t=e instanceof Error?e:new Error(String(e));if(this.strict)throw t;this.onError?.(t);}};
exports.LogStitch=m;exports.LogStitchError=a;