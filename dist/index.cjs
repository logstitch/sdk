'use strict';var a=class i extends Error{status;code;requestId;constructor(e,t,r,s){super(e),this.name="LogStitchError",this.status=t,this.code=r,this.requestId=s;}static async fromResponse(e){let t="unknown_error",r=`HTTP ${e.status}`,s="";try{let n=await e.json();n.error&&(t=n.error.code??t,r=n.error.message??r),s=n.request_id??"";}catch{}return new i(r,e.status,t,s)}};async function c(i,e,t){let r=3,s=500,n=3e4,h;for(let o=0;o<r;o++){let u;try{u=await fetch(i,e);}catch(m){if(h=m instanceof Error?m:new Error(String(m)),o<r-1){await y(d(o,s,n));continue}throw h}if(u.ok||u.status>=400&&u.status<500)return u;h=new Error(`HTTP ${u.status}`),o<r-1&&await y(d(o,s,n));}throw h??new Error("fetchWithRetry: exhausted retries")}function d(i,e,t){let r=e*2**i,s=Math.min(r,t),n=s*Math.random();return s+n}function y(i){return new Promise(e=>setTimeout(e,i))}var l=class{queue=[];timer=null;batchSize;flushInterval;maxQueueSize;onFlush;flushing=false;constructor(e){this.batchSize=e.batchSize,this.flushInterval=e.flushInterval,this.maxQueueSize=e.maxQueueSize,this.onFlush=e.onFlush;}enqueue(e){this.queue.length>=this.maxQueueSize||(e.idempotency_key||(e={...e,idempotency_key:crypto.randomUUID()}),this.queue.push(e),this.startTimer(),this.queue.length>=this.batchSize&&this.flush());}async flush(){if(this.flushing||this.queue.length===0)return;this.flushing=true;let e=this.queue.splice(0);try{await this.onFlush(e);}finally{this.flushing=false;}}async close(){this.stopTimer(),await this.flush();}get size(){return this.queue.length}startTimer(){this.timer===null&&(this.timer=setInterval(()=>{this.flush();},this.flushInterval));}stopTimer(){this.timer!==null&&(clearInterval(this.timer),this.timer=null);}};var v="https://logstitch.io",f=10,E=5e3,g=1e3,p=class i{baseUrl;projectKey;strict;onError;queue;mode;streamToken;events;viewerTokens;static stream(e){let t=e?.token??crypto.randomUUID(),r=new i({projectKey:"__stream__",baseUrl:e?.baseUrl,batchSize:e?.batchSize,flushInterval:e?.flushInterval,maxQueueSize:e?.maxQueueSize,strict:e?.strict,onError:e?.onError},{mode:"stream",streamToken:t}),s=(e?.baseUrl??v).replace(/\/+$/,"");return console.log(`LogStitch Stream Mode \u2014 Claim at: ${s}/claim?token=${t}`),r}get token(){return this.streamToken}constructor(e,t){if(this.mode=t?.mode??"authenticated",this.streamToken=t?.streamToken??null,this.mode==="authenticated"&&!e.projectKey)throw new Error("LogStitch: projectKey is required");this.projectKey=e.projectKey,this.baseUrl=(e.baseUrl??v).replace(/\/+$/,""),this.strict=e.strict??false,this.onError=e.onError,this.queue=new l({batchSize:e.batchSize??f,flushInterval:e.flushInterval??E,maxQueueSize:e.maxQueueSize??g,onFlush:r=>this._send(r)}),this.mode==="stream"?(this.events={list:()=>{throw new Error("LogStitch: events.list() is not available in stream mode")}},this.viewerTokens={create:()=>{throw new Error("LogStitch: viewerTokens.create() is not available in stream mode")}}):(this.events={list:r=>this._listEvents(r)},this.viewerTokens={create:r=>this._createViewerToken(r)});}async log(e){try{this.queue.enqueue(e);}catch(t){this._handleError(t);}}async logBatch(e){let t=e.map(r=>r.idempotency_key?r:{...r,idempotency_key:crypto.randomUUID()});return this._sendAndReturn(t)}async flush(){await this.queue.flush();}async close(){await this.queue.close();}async _send(e){try{await this._sendAndReturn(e);}catch(t){this._handleError(t);}}async _sendAndReturn(e){let t=this.mode==="stream"?`${this.baseUrl}/api/v1/streams/${this.streamToken}/events`:`${this.baseUrl}/api/v1/events`,r={"Content-Type":"application/json"};this.mode==="authenticated"&&(r.Authorization=`Bearer ${this.projectKey}`);let s=await c(t,{method:"POST",headers:r,body:JSON.stringify(e.length===1?e[0]:e)});if(!s.ok)throw await a.fromResponse(s);return await s.json()}async _listEvents(e){let t=new URLSearchParams;if(e)for(let[h,o]of Object.entries(e))o!=null&&t.set(h,String(o));let r=t.toString(),s=`${this.baseUrl}/api/v1/events${r?`?${r}`:""}`,n=await c(s,{method:"GET",headers:{Authorization:`Bearer ${this.projectKey}`}});if(!n.ok)throw await a.fromResponse(n);return await n.json()}async _createViewerToken(e){let t=await c(`${this.baseUrl}/api/v1/viewer-tokens`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.projectKey}`},body:JSON.stringify(e)});if(!t.ok)throw await a.fromResponse(t);return await t.json()}_handleError(e){let t=e instanceof Error?e:new Error(String(e));if(this.strict)throw t;this.onError?.(t);}};
exports.LogStitch=p;exports.LogStitchError=a;